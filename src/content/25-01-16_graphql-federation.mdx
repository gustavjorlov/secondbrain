# graphql federation

[Voyage 1 - youtube](https://youtu.be/DGAkGULuwEI?si=00G6yj9ET8waWHjE)

[10 Best Practices for Schema Stewardship (Part 1 of 2)](https://www.apollographql.com/blog/10-best-practices-for-schema-stewardship)

## 10 Broad Concepts for Operating a Federated GraphQL Server in Production  

1. **Subgraph Schema Design**  
   - Design schemas with well-defined ownership of types and clear boundaries between services.  
   - Use federation directives like `@key`, `@external`, and `@requires` to manage type relationships effectively.  

2. **GraphQL Gateway Management**  
   - Set up and configure a robust GraphQL gateway for query delegation.  
   - Optimize query plans generated by the gateway to minimize latency and resolve cross-service dependencies efficiently.  

3. **API Versioning and Schema Evolution**  
   - Adopt strategies for non-breaking schema changes, such as adding fields instead of removing or renaming them.  
   - Use tools like Apollo Studio or schema registries to track and validate schema changes across subgraphs.  

4. **Service Discovery and Configuration**  
   - Dynamically register and discover subgraphs using service registries or configuration files.  
   - Implement failover and fallback mechanisms for when a subgraph is unavailable.  

5. **Performance Monitoring and Optimization**  
   - Monitor gateway and subgraph performance using tools like Apollo Studio or Prometheus.  
   - Optimize resolvers and batch requests using tools like `DataLoader`.  

6. **Authentication and Authorization**  
   - Centralize authentication in the gateway or handle it in individual subgraphs based on your requirements.  
   - Use federation-specific techniques for propagating user context securely across subgraphs.  

7. **Error Handling and Debugging**  
   - Implement consistent error formats across subgraphs and handle errors gracefully at the gateway level.  
   - Use logging tools and distributed tracing (e.g., OpenTelemetry) to debug requests across services.  

8. **Deployment and CI/CD Pipeline**  
   - Automate deployments with CI/CD pipelines that validate schema compatibility between subgraphs and the gateway.  
   - Implement staging environments to test changes in isolation before production deployment.  

9. **Local Development Environment**  
   - Provide developers with tools to spin up local versions of the gateway and subgraphs.  
   - Use mock servers or Apollo Sandbox to simulate subgraph interactions.  

10. **Caching and Rate Limiting**  
   - Implement caching mechanisms at both the gateway (e.g., persisted queries) and subgraph levels.  
   - Enforce rate limits to protect subgraphs from being overwhelmed by expensive queries.  

By mastering these concepts, you can ensure your federated GraphQL server operates efficiently in production while fostering a smooth development experience for your team.

---

## Custom Directives

GraphQL Federation introduces a set of custom directives that allow you to define how services will collaborate and extend a unified schema. Below is a list of the key custom directives in GraphQL Federation with a brief description of each:

1. @key
- Description: Marks the field or fields that uniquely identify an entity within a service. This is used to enable entity resolution across multiple federated services. You can specify a single field or a combination of fields as the key for an entity.
- Usage:
```
type Product @key(fields: "id") {
  id: ID!
  name: String
}
```

2. @external
- Description: Marks a field as being defined by another service. This is used when you need to reference a field that is part of an entity but is not owned by the current service.
- Usage:
```
type Product {
  id: ID!
  name: String
  price: Float @external
}
```

3. @requires
- Description: Specifies that a field in a federated service requires other fields from the same entity to be resolved. This is typically used when the current service doesn't own all fields required to compute a field, but needs them to be present to resolve its field.
- Usage:
```
type Product @key(fields: "id") {
  id: ID!
  name: String
  price: Float
  discountedPrice: Float @requires(fields: "price")
}
```

4. @provides
- Description: Indicates that a field in a service provides additional data for an entity to be resolved by other services. This is often used when a service enriches an entity with fields that are then used by other services.
- Usage:
```
type Product @key(fields: "id") {
  id: ID!
  name: String
}

extend type Product {
  discountedPrice: Float @provides(fields: "discountedPrice")
}
```

5. @extends
- Description: Marks a type as an extension of another type defined in a different service. This is used when a type is initially defined in one service, and then extended in other services to add more fields.
- Usage:
```
extend type Product @key(fields: "id") {
  discountedPrice: Float
}
```

6. @shareable
- Description: Used for fields that are shared across multiple services, typically for things like common types or fields that need to be accessed in multiple federated schemas.
- Usage:
```
type CommonInfo @shareable {
  id: ID!
  value: String
}
```

7. @inaccessible
- Description: Marks a field or type as inaccessible to other services, meaning the field cannot be queried by other services in the federation. It can still be used within the same service.
- Usage:
```
type Product {
  id: ID!
  name: String
  secretInfo: String @inaccessible
}
```

---

## A Short Tutorial on GraphQL Federation

GraphQL Federation is a technique to manage and scale GraphQL APIs by composing multiple GraphQL services into a single unified graph. It allows teams to independently develop, deploy, and maintain their own GraphQL schemas while enabling seamless querying across the federated services. Federation is particularly useful for organizations with microservices architectures.

Key Concepts of GraphQL Federation

1.	Gateway: Acts as the entry point for clients, unifying multiple subgraphs into a single API.
2.	Subgraphs: Independent GraphQL services that contribute their schema and data to the unified graph.
3.	Schema Stitching vs. Federation: Unlike schema stitching, Federation provides more flexibility with declarative composition and dynamic runtime resolution.

Steps to Implement GraphQL Federation

### 1. Setup Subgraphs

Each service represents a subgraph and defines its own GraphQL schema.

Example Schema for Service 1 (Users Service):
```
type User @key(fields: "id") {
  id: ID!
  name: String!
}
type Query {
  getUser(id: ID!): User
}
```

Example Schema for Service 2 (Orders Service):
```
type Order @key(fields: "id") {
  id: ID!
  description: String!
  userId: ID!
}

extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order]
}

type Query {
  getOrder(id: ID!): Order
}
```

	•	@key: Identifies the primary field(s) used to uniquely identify a type across services.
	•	@external: Indicates fields defined in another service.

### 2. Install Required Libraries

You’ll need the following libraries for federation. Install them using your package manager (e.g., npm or yarn).

For subgraphs:

`npm install @apollo/subgraph graphql`

For the gateway:

`npm install @apollo/gateway graphql`

### 3. Build Subgraph Services

Create an executable schema and run a GraphQL server for each subgraph.

Example Users Service (Node.js/Express):

```
const { ApolloServer } = require('@apollo/server');
const { buildSubgraphSchema } = require('@apollo/subgraph');
const { gql } = require('graphql-tag');

const typeDefs = gql`
  type User @key(fields: "id") {
    id: ID!
    name: String!
  }
  type Query {
    getUser(id: ID!): User
  }
`;

const resolvers = {
  Query: {
    getUser: (_, { id }) => ({ id, name: "John Doe" }),
  },
  User: {
    __resolveReference: (user) => ({ id: user.id, name: "John Doe" }),
  },
};

const server = new ApolloServer({
  schema: buildSubgraphSchema({ typeDefs, resolvers }),
});

server.listen({ port: 4001 }).then(({ url }) => {
  console.log(`Users service running at ${url}`);
});
```

Repeat similar steps for the Orders service.

### 4. Set Up the Gateway

The gateway combines subgraphs into a single unified graph.

Gateway Example:
```
const { ApolloGateway } = require('@apollo/gateway');
const { ApolloServer } = require('@apollo/server');

const gateway = new ApolloGateway({
  subgraphs: [
    { name: 'users', url: 'http://localhost:4001' },
    { name: 'orders', url: 'http://localhost:4002' },
  ],
});

const server = new ApolloServer({
  gateway,
  introspection: true,
});

server.listen({ port: 4000 }).then(({ url }) => {
  console.log(`Federated GraphQL Gateway running at ${url}`);
});
```

### 5. Test the Unified Graph

Query the gateway to fetch data from multiple subgraphs in one request.

Example Query:

```
query {
  getUser(id: "1") {
    id
    name
    orders {
      id
      description
    }
  }
}
```

This query retrieves user data from the Users service and orders data from the Orders service.

Advantages of GraphQL Federation
	•	Scalability: Enables multiple teams to independently manage subgraphs.
	•	Modularity: Breaks down a monolithic schema into smaller, manageable subgraphs.
	•	Flexibility: Services can evolve independently, reducing dependencies.

GraphQL Federation is a powerful approach for teams building large-scale, distributed applications. By using Apollo Federation, you can efficiently create a unified graph while maintaining the autonomy of individual services.
